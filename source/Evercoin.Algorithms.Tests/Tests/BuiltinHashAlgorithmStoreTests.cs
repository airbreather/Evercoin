using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

using Moq;

using Xunit;
using Xunit.Extensions;

namespace Evercoin.Algorithms.Tests
{
    public sealed class BuiltinHashAlgorithmStoreTests
    {
        public static IEnumerable<object[]> KnownHashAlgorithms
        {
            get
            {
                return new[]
                {
                    new object[] { HashAlgorithmIdentifiers.SHA1 },
                    new object[] { HashAlgorithmIdentifiers.SHA256 },
                    new object[] { HashAlgorithmIdentifiers.LitecoinSCrypt },
                    new object[] { HashAlgorithmIdentifiers.RipeMd160 },
                    new object[] { HashAlgorithmIdentifiers.DoubleSHA256 },
                    new object[] { HashAlgorithmIdentifiers.SHA256ThenRipeMd160 }
                };
            }
        }

        public static IEnumerable<object[]> KnownHashAlgorithmResults
        {
            get
            {
                return new[]
                {
                    // I promise that none of the expected results were generated by running the underlying code!
                    // I used https://github.com/tonyg/js-scrypt for the SCrypt one.
                    // Then I used http://www.fileformat.info/tool/hash.htm for everything else.
                    new object[] { HashAlgorithmIdentifiers.SHA1, "The quick brown fox jumps over the lazy dog.", "408d94384216f890ff7a0c3528e8bed1e0b01621" },
                    new object[] { HashAlgorithmIdentifiers.SHA256, "The dog doesn't appreciate being characterized as lazy.", "3df436311f0f55f64356c72a590849714463124031d799a5b9845f1f1e41a840" },
                    new object[] { HashAlgorithmIdentifiers.LitecoinSCrypt, "The fox doesn't understand why we need to point out the fact that he's brown.", "6f268e59b5e727b9128a60a4fb95072f088e00ed7355f71f6768ea96c5fa6d63" },
                    new object[] { HashAlgorithmIdentifiers.RipeMd160, "A linguist tells the fox and the dog that the initial sentence is specially crafted to include all the letters of the alphabet.", "6fc2982b8323455ac1f9a3a5549113a8c6b86fd9" },
                    new object[] { HashAlgorithmIdentifiers.DoubleSHA256, "The fox and the dog realize that it's their unique qualities that make them useful to the world outside of themselves.", "fbe392e4f25f540829a26f9d4cf25bf736e257ea2cb68ea78b454074917a50b2" },
                    new object[] { HashAlgorithmIdentifiers.SHA256ThenRipeMd160, "The dog lies down, and the fox sets up beside him.  Triumphantly, the quick brown fox jumps over the proud, lazy dog.", "a599df7fe4c9574966befca95a314d5d218db7c7" }
                };
            }
        }

        [Theory]
        [PropertyData("KnownHashAlgorithms")]
        public void GetHashAlgorithmShouldReturnKnownAlgorithm(Guid knownAlgorithmIdentifier)
        {
            BuiltinHashAlgorithmStore sut = new BuiltinHashAlgorithmStore();

            IHashAlgorithm algorithm = sut.GetHashAlgorithm(knownAlgorithmIdentifier);

            Assert.NotNull(algorithm);
        }

        [Fact]
        public void GetHashAlgorithmShouldFailOnUnknownAlgorithm()
        {
            BuiltinHashAlgorithmStore sut = new BuiltinHashAlgorithmStore();
            Guid unknownIdentifier = Guid.NewGuid();

            Assert.Throws<KeyNotFoundException>(() => sut.GetHashAlgorithm(unknownIdentifier));
        }

        [Fact]
        public void RegisterHashAlgorithmShouldFail()
        {
            IHashAlgorithmStore sut = new BuiltinHashAlgorithmStore();
            Guid someGuid = Guid.NewGuid();
            IHashAlgorithm someAlgorithm = Mock.Of<IHashAlgorithm>();

            Assert.Throws<NotSupportedException>(() => sut.RegisterHashAlgorithm(someGuid, someAlgorithm));
        }

        [Theory]
        [PropertyData("KnownHashAlgorithmResults")]
        public void GetHashAlgorithmResultShouldReturnCanonicalResults(Guid knownAlgorithmIdentifier, string utf8Input, string expectedHexResult)
        {
            byte[] input = Encoding.UTF8.GetBytes(utf8Input);
            IEnumerable<byte> expectedResult = HexStringToByteArray(expectedHexResult);

            BuiltinHashAlgorithmStore sut = new BuiltinHashAlgorithmStore();
            IHashAlgorithm algorithm = sut.GetHashAlgorithm(knownAlgorithmIdentifier);

            IEnumerable<byte> actualResult = algorithm.CalculateHash(input);

            Assert.Equal(expectedResult, actualResult);
        }

        private static IEnumerable<byte> HexStringToByteArray(string hexString)
        {
            int byteCount = hexString.Length / 2;
            byte[] result = new byte[byteCount];
            using (StringReader sr = new StringReader(hexString))
            {
                for (int i = 0; i < byteCount; i++)
                {
                    // Read 2 characters, each representing a nibble.
                    char nibble1 = (char)sr.Read();
                    char nibble2 = (char)sr.Read();

                    string hexByte = String.Concat(nibble1, nibble2);

                    // The new 2-char string is a number in base-16.
                    result[i] = Convert.ToByte(hexByte, 16);
                }
            }

            return result;
        }
    }
}
